/* DO NOT EDIT!
   This file was automatically generated by m68k-palmos-stubgen v1.2
   from ssl-des.def  */

struct LibRef;
static struct LibRef *libref = 0;

extern void GLibClose(struct LibRef *);

#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
/* Recent versions of prc-tools's GCC use %a4 or %a5 depending on -mown-gp.  */
    #ifdef __OWNGP__
    #define A4_GLOBALS
    #else
    #undef A4_GLOBALS
    #endif
#else
/* The prc-tools 0.5.0 version always uses %a4.  */
#define A4_GLOBALS
#endif

void GLib_CrDS(void)
{
    asm volatile ("
	.global _des_check_key_ptr
_des_check_key_ptr:
	move.l	#1,%%d0
	braw	dispatch
	.global _des_crypt
_des_crypt:
	move.l	#2,%%d0
	braw	dispatch
	.global crypt
crypt:
	move.l	#3,%%d0
	braw	dispatch
	.global des_3cbc_encrypt
des_3cbc_encrypt:
	move.l	#4,%%d0
	braw	dispatch
	.global des_cbc_cksum
des_cbc_cksum:
	move.l	#5,%%d0
	braw	dispatch
	.global des_cbc_encrypt
des_cbc_encrypt:
	move.l	#6,%%d0
	braw	dispatch
	.global des_cfb64_encrypt
des_cfb64_encrypt:
	move.l	#7,%%d0
	braw	dispatch
	.global des_cfb_encrypt
des_cfb_encrypt:
	move.l	#8,%%d0
	braw	dispatch
	.global des_decrypt3
des_decrypt3:
	move.l	#9,%%d0
	braw	dispatch
	.global des_ecb3_encrypt
des_ecb3_encrypt:
	move.l	#10,%%d0
	braw	dispatch
	.global des_ecb_encrypt
des_ecb_encrypt:
	move.l	#11,%%d0
	braw	dispatch
	.global des_ede3_cbc_encrypt
des_ede3_cbc_encrypt:
	move.l	#12,%%d0
	braw	dispatch
	.global des_ede3_cfb64_encrypt
des_ede3_cfb64_encrypt:
	move.l	#13,%%d0
	braw	dispatch
	.global des_ede3_ofb64_encrypt
des_ede3_ofb64_encrypt:
	move.l	#14,%%d0
	braw	dispatch
	.global des_encrypt
des_encrypt:
	move.l	#15,%%d0
	braw	dispatch
	.global des_encrypt2
des_encrypt2:
	move.l	#16,%%d0
	braw	dispatch
	.global des_encrypt3
des_encrypt3:
	move.l	#17,%%d0
	braw	dispatch
	.global des_fcrypt
des_fcrypt:
	move.l	#18,%%d0
	braw	dispatch
	.global des_is_weak_key
des_is_weak_key:
	move.l	#19,%%d0
	braw	dispatch
	.global des_key_sched
des_key_sched:
	move.l	#20,%%d0
	braw	dispatch
	.global des_ncbc_encrypt
des_ncbc_encrypt:
	move.l	#21,%%d0
	braw	dispatch
	.global des_ofb64_encrypt
des_ofb64_encrypt:
	move.l	#22,%%d0
	braw	dispatch
	.global des_ofb_encrypt
des_ofb_encrypt:
	move.l	#23,%%d0
	braw	dispatch
	.global des_options
des_options:
	move.l	#24,%%d0
	braw	dispatch
	.global des_pcbc_encrypt
des_pcbc_encrypt:
	move.l	#25,%%d0
	braw	dispatch
	.global des_quad_cksum
des_quad_cksum:
	move.l	#26,%%d0
	braw	dispatch
	.global des_random_key
des_random_key:
	move.l	#27,%%d0
	braw	dispatch
	.global des_random_seed
des_random_seed:
	move.l	#28,%%d0
	braw	dispatch
	.global des_set_key
des_set_key:
	move.l	#29,%%d0
	braw	dispatch
	.global des_set_odd_parity
des_set_odd_parity:
	move.l	#30,%%d0
	braw	dispatch
	.global des_string_to_2keys
des_string_to_2keys:
	move.l	#31,%%d0
	braw	dispatch
	.global des_string_to_key
des_string_to_key:
	move.l	#32,%%d0
	braw	dispatch
	.global des_xcbc_encrypt
des_xcbc_encrypt:
	move.l	#33,%%d0
	braw	dispatch
	.global des_xwhite_in2out
des_xwhite_in2out:
	move.l	#34,%%d0
	braw	dispatch
	.global fcrypt_body
fcrypt_body:
	move.l	#35,%%d0
	braw	dispatch

libname:
    .asciz \"DES Library\"
    .even

dispatch:
    lea libname(%%pc),%%a1
    move.l %%a1,%%d2
    "::);

#ifdef A4_GLOBALS
    asm volatile ("
    move.l %%a4,%%d1
    move.l %%d1,%%d1
    jbeq noglobals
    lea libref(%%a4),%%a1
noglobals:
    "::);
#else
    asm volatile ("
    lea libref@END(%%a5),%%a1
    "::);
#endif

    asm volatile ("
    move.l %0,%%d1
    braw GLibDispatch
    " : : "i" ('CrDS') );
}

#ifdef A4_GLOBALS

/* The 0.5.0 distribution didn't use a .dtors section.  In order to
   be usable with that compiler, we use a .ehook function and check
   for globals ourselves.  */

register void *reg_a4 asm("%a4");

void GLib_CrDS_clean(unsigned short cmd, void *PBP, unsigned short flags)
{
    if (reg_a4 && libref) {
	GLibClose(libref);
	libref = 0;
    }
}

asm("
.section ehook
.long GLib_CrDS_clean
");

#else

static void GLib_CrDS_clean() __attribute__ ((destructor, unused));

static void GLib_CrDS_clean()
{
    if (libref) {
	GLibClose(libref);
	libref = 0;
    }
}

#endif

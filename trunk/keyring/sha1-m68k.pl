#!/usr/bin/perl
print <<EOF;
#
# Keyring -- store passwords securely on a handheld
# Copyright (C) 2003 Jochen Hoenicke <hoenicke@users.sourceforge.net>
#
# $Id$
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

#
# This is a hand optimized of SHA1.  This assembler code is autogenerated
# by a perl script.  Always change the Perl script.
#
EOF

$SECTION=".text";
open SECTIONS_H, "<sections.h";
while (<SECTIONS_H>) {
    if (/\#define\s+SHA1_SECTION\s+__attribute__\s*
	\(\(section\s*\("(.*)"\)\)\)/x) {
	$SECTION = qq(.section\t$1,"x");
	last;
    }
}
close SECTIONS_H;

print <<EOF;

	.file	"sha1-m68k.s"

$SECTION
	.even
.globl SHA1_Block
SHA1_Block:

	link.w %a6,\#-56
	movm.l \#0x1f38,-(%sp)
	move.l 8(%a6),%a0
        movm.l (%a0), \#0x001f
	move.l 12(%a6),%a0
EOF


$A='%d0';
$B='%d1';
$C='%d2';
$D='%d3';
$E='%d4';
$T='%d5';

$K='%a4';

@CACHE1 = ('%a1','%a2', '%a3');
@CACHE2 = ('%d6', '%d7');

@K=(0x5a827999,0x6ed9eba1,0x8f1bbcdc,0xca62c1d6);

$WAITSTATES = 4;



    my $cycles = 16 + 8 + 8*8 + 7*16;
    $cycles += (4 + 18 + 4+4+3+16) * $WAITSTATES;


    sub W($) {
	my ($i) = @_;
	my $j;
	if ($i < 16) {
	    $j =  ($i-15)*4;
	    $j = "" if ($j == 0);
	    return "$j(%a0)";
	} else {
	    $j = -56 + 4*(($i-16) % 14); # -64 + 4*($i & 15);
	    return "$j(%a6)";
	}
    }

    sub FUNC($$$$$) {
	my ($i,$B,$C,$D, $T) = @_;
	if ($i < 20) {
	    $cycles += 4 + 8 + 8 + 8 + 4*$WAITSTATES;
	    print "\tmove.l $D, $T\n";
	    print "\teor.l  $C, $T\n";
	    print "\tand.l  $B, $T\n";
	    print "\teor.l  $D, $T\n";
	} elsif ($i < 40) {
	    $cycles += 4 + 8 + 8 + 3*$WAITSTATES;
	    print "\tmove.l $D, $T\n";
	    print "\teor.l  $C, $T\n";
	    print "\teor.l  $B, $T\n";
	} elsif ($i < 60) {
	    $cycles += 8 + 4 + 8 + 8 + 8 + 8 + 6*$WAITSTATES;
	    print "\teor.l $B, $D\n";
	    print "\tmove.l $C, $T\n";
	    print "\teor.l  $B, $T\n";
	    print "\tand.l  $D, $T\n";
	    print "\teor.l  $B, $D\n";
	    print "\teor.l  $B, $T\n";
	} else {
	    $cycles += 4 + 8 + 8 + 3*$WAITSTATES;
	    print "\tmove.l $D, $T\n";
	    print "\teor.l  $C, $T\n";
	    print "\teor.l  $B, $T\n";
	}
    }

    for ($i = 0; $i < 80; $i++) {
	my $tmp;
	print "\n\t\# Round $i cycles: $cycles\n";
	print "\t\# A=$A B=$B C=$C D=$D E=$E\n";

	print "\tmove.l \#$K[$i/20], $K\n" if (($i % 20) == 0);
	$cycles += 12  if (($i % 20) == 0);

	print "\tlea.l  -56(%a0), %a0\n" if ($i == 16);
	print "\tlea.l  -56(%a6), %a0\n" if ($i >= 30 && (($i-30) % 14) == 0);

	if ($i >= 16) {
	    print "\t\# W[".($i-16)."]=$CACHE2[0] W[".($i-15)."]=$CACHE2[1]";
	    print " W[".($i-3)."]=$CACHE1[0] W[".($i-2)."]=$CACHE1[1]".
		" W[".($i-1)."]=$CACHE1[2]\n";
	    print "\tmove.l $CACHE1[0], $T\n";
	    print "\teor.l  $CACHE2[0], $T\n";
	    print "\tmove.l ".($i-8 < 16 ? "24(%a0)":W($i-8)).", $CACHE2[0]\n";
	    print "\teor.l  $CACHE2[0], $T\n";
	    print "\tmove.l (%a0)".($i >= 30 && $i < 80-8 ? "" : "+").", $CACHE2[0]\n";
	    print "\teor.l  $CACHE2[0], $T\n";
	    print "\trol.l  \#1, $T\n";

	    print "\tmove.l $T, ". ($i >= 30 ? "(%a0)+" : W($i))."\n"
		if ($i < 80-8);
	    print "\tmove.l $T, $CACHE1[0]\n" if ($i < 80-3);
	    print "\tadd.l  $T, $E\n";
	    $cycles += 16 + 16 + 8 + 16 + 8 + 16 + 8 + 10 + 8;
	    $cycles += 22 * $WAITSTATES;
	    $cycles += 16 + 4*$WAITSTATES if ($i < 80-3);

	    $tmp = $CACHE1[0];
	    $CACHE1[0] = $CACHE1[1];
	    $CACHE1[1] = $CACHE1[2];
	    $CACHE1[2] = $tmp;

	    $tmp = $CACHE2[0];
	    $CACHE2[0] = $CACHE2[1];
	    $CACHE2[1] = $tmp;
	} else {
	    # take W[i] from (%a0) ;  but cache it if we need it later.
	    if ($i < 2 || $i >= 13) {
		$reg = $i < 2 ? $CACHE2[$i] : $CACHE1[$i-13];
		if ($i >= 13) {
		    print "\tmovm.l  (%a0)+, \#0x0e00\n" if ($i == 13);
		} else {
		    print "\tmove.l  (%a0)+, $reg\n";
		}
		print "\tadd.l  $reg, $E\n";
		$cycles += 16 + 4*$WAITSTATES + 8 + 1*$WAITSTATE;
	    } else {
		print "\tadd.l  (%a0)+, $E\n";
		$cycles += 18 + 4*$WAITSTATES;
	    }
	}
	FUNC($i, $B, $C, $D, $T);
	print "\tadd.l  $T, $E\n";

	print "\tadd.l  $K, $E\n";
	print "\tmove.l $A, $T\n";
	print "\trol.l  \#5, $T\n";
	print "\tadd.l  $T, $E\n";

	print "\tror.l  \#2, $B\n";
	$cycles += 8 + 8 + 4 + 18 + 8 + 12 + 8*$WAITSTATES;

	$tmp = $E;
	$E = $D;
	$D = $C;
	$C = $B;
	$B = $A;
	$A = $tmp;
    }	

    print "\n\t\# Finishing.  Cycles: $cycles\n";

print <<EOF;
	move.l 8(%a6),%a0
	move.l 16(%a6),%a1
	add.l (%a0)+,$A
	move.l $A,(%a1)+
	add.l (%a0)+,$B
	move.l $B,(%a1)+
	add.l (%a0)+,$C
	move.l $C,(%a1)+
	add.l (%a0)+,$D
	move.l $D,(%a1)+
	add.l (%a0),$E
	move.l $E,(%a1)
	movm.l (%sp)+,#0x1cf8
	unlk %a6
	rts
	.byte 0x8a
	.ascii "SHA1_Block"
	.byte 0x0
	.word 0
EOF
    $cycles += 16 + 5*(16+12) + 12 + 8*8 + 12 + 16;
    $cycles += (4 + 5*6 + 18 + 1 + 1) * $WAITSTATES;
    print "\n\t\# Total cycles: $cycles\n";

$current_file="";
if ($headername=="") {
    $headername="_PROTO_H_";
}

print "/* This file is automatically generated with \"make proto\". DO NOT EDIT */\n\n";
print "#ifndef $headername\n";
print "#define $headername\n";

sub parseFuncDefinition($) {
    $_ = $_[0];
    $_ =~ s/\s+/ /g;
    $_ =~ s/^\s//;
    $_ =~ s/\s$//;

    if (/^static|^extern/ || !/^[a-zA-Z_]/) {
	return;
    }

    if (!/\(.*\)/) {
	return;
    }

    print "extern $_;\n";
}

sub parseVarDefinition($) {
    $_ = $_[0];
    $_ =~ s/\s+/ /g;
    $_ =~ s/^\s//;
    $_ =~ s/\s$//;

    # skip static/extern/typedef or nonalphanumeric things
    return if /^(static |extern |typedef |[^a-zA-Z_])/;
    # skip simple struct/class definition
    return if /^(struct|class) [a-zA-Z_]+$/;
    if (!/[a-zA-Z0-9_] [a-zA-Z_]/) {
	return;
    }
    print "extern $_;\n";
}

while (<>)
{
    if ($ARGV ne $current_file) {
	if ($bracelevel || $incomment || $instring || $inchar
	    || $inif || $inifactive || $definitions !~ /^\s*$/) {
	    print STDERR "Warning: Couldn't parse $current_file.\n";
	}
	print "\n/* The following definitions come from $ARGV */\n\n";
	$current_file = $ARGV;
	$bracelevel = 0;
	$incomment = 0;
	$instring = 0;
	$inchar = 0;
	$inif = 0;
	$inifactive = 0;
	$wasactive = ();
	$definition = "";
    }

#    print STDERR "read:$instring$inchar$incomment:$_";

    # Handle if directives:  We parse #ifndef and #if 1 nodes and handle
    # else and elif correctly.
    if ($_ =~ /^\#(el)?if/) {
	if (!$1) {
	    $inif++;
	}
	if ($inifactive + 1 == $inif
	    && $_ =~ /^\#(el)?if(ndef\s.*|\s+1)$/) {
	    $inifactive++;
	} elsif ($inifactive == $inif) {
	    $inifactive--;
	    $wasactive[$inif] = 1;
	}
    } elsif ($_ =~ /^\#else/) {
	if ($inifactive + 1 == $inif && !$wasactive[$inif]) {
	    $inifactive++;
	} elsif ($inifactive == $inif) {
	    $inifactive--;
	    $wasactive[$inif] = 1;
	}
    } elsif ($_ =~ /^\#endif/) {
	if ($inifactive == $inif) {
	    $inifactive--;
	}
	$wasactive[$inif] = 0;
	$inif--;
    }

    next if $_ =~ /^\#/ || ($inifactive < $inif);

    while ($_) {
	if ($incomment) {
	    if ($_ =~ s/^([^\*]|\*+[^\*\/])*\*+\///) {
		$incomment = 0;
	    } else {
		last;
	    }
	}

	if ($instring) {
	    if ($_ =~ s/([^\\\"]|\\.)*//) {
		$instring = 0;
	    } else {
		last;
	    }
	}

	if ($inchar) {
	    if ($_ =~ s/([^\\\']|\\.)*//) {
		$inchar = 0;
	    } else {
		last;
	    }
	}
    
	$_ =~ s/^(([^\{\}\"\'\;\/]|\/[^\/\*])*)//;
	if (!$bracelevel) {
	    $definition .= "$1 ";
	}

#	$foo = $1;
#	if ($foo !~ /^\s*$/) {
#	    $foo =~ s/\n//g;
#	    print STDERR "$bracelevel:$foo:\n";
#	}

	if ($_ =~ s/^\{//) {
	    if (!$bracelevel) {
		$tmp = $_;
		parseFuncDefinition($definition);
		$_ = $tmp;
		$definition = "";
	    }
	    $bracelevel++;
	} elsif ($_ =~ s/^\}//) {
	    $bracelevel--;
	} elsif ($_ =~ s/^\/\*//) {
	    $incomment = 1;
	} elsif ($_ =~ s/^\"//) {
	    $instring = 1;
	} elsif ($_ =~ s/^\'//) {
	    $inchar = 1;
	} elsif ($_ =~ s/^\/\///) {
	    last;
	} elsif ($_ =~ s/^;//) {
	    if (!$bracelevel) {
		$tmp = $_;
		parseVarDefinition($definition);
		$_ = $tmp;
		$definition = "";
	    }
	}
    }
}

print "\n#endif /* _PROTO_H_ */\n";

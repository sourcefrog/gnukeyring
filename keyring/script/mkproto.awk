BEGIN {
  inheader=0;
  current_file="";
  if (headername=="") {
    headername="_PROTO_H_";
  }

  print "#ifndef",headername
  print "#define",headername
  print "/* This file is automatically generated with \"make proto\". DO NOT EDIT */"
  print ""
}

END {
  print "#endif /* _PROTO_H_ */"
}

{
  if (FILENAME!=current_file) {
#    if (use_ldap_define)
#    {
#      print "#endif /* USE_LDAP */"
#      use_ldap_define = 0;
#    }
    print ""
    print "/* The following definitions come from", FILENAME, "*/"
    print ""
    current_file=FILENAME
  }
  if (inheader) {
    if (match($0,"[)][ \t]*$")) {
      inheader = 0;
      printf "%s;\n",$0;
    } else {
      printf "%s\n",$0;
    }
    next;
  }
}


/^static|^extern/ || !/^[a-zA-Z]/ || /[;]/ {
  next;
}

#
# We have to split up the start
# matching as we now have so many start
# types that it can cause some versions
# of nawk/awk to choke and fail on
# the full match. JRA.
#

{
  gotstart = 0;
  if ($0 ~ /^NOPROTO/) {
    gotstart = 0;
    next;
  }

  if ($0 ~ /^(const|long|char|signed|unsigned|short|int|struct|void|time|FILE|size_t|n4err|enum)/) {
    gotstart = 1;
  }
  
  if ($0 ~ /^[A-Za-z]+(Ptr|Handle)/) {
    gotstart = 1;
  }
  
  if ($0 ~ /^(Bool|Err)/) {
    gotstart = 1;
  }
  
  if ($0 ~ /^gu?int(8|16|32|64)/) {
    gotstart = 1;
  }
  
  if ($0 ~ /^U?Int(8|16|32|64)/) {
    gotstart = 1;
  }
  
  if ($0 ~ /^bool_t|^u?int(8|16|32|64)_t/) {
    gotstart = 1;
  }
  
  if ($0 ~ /^n4[a-z0-9_]+_t /) {
    gotstart = 1;
  }
  
  if ( $0 ~ /^MKPROTO/ ) {
    gotstart = 1;
  }

  if(!gotstart) {
    next;
  }
}


/[(].*[)][ \t]*$/ {
    printf "%s;\n",$0;
    next;
}

/[(]/ {
  inheader=1;
  printf "%s\n",$0;
  next;
}


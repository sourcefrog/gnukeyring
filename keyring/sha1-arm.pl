#!/usr/bin/perl
print <<'EOF';
#
# Keyring -- store passwords securely on a handheld
# Copyright (C) 2003 Jochen Hoenicke <hoenicke@users.sourceforge.net>
#
# $Id$
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

#
# This is a hand optimized of SHA1.  This assembler code is autogenerated
# by a perl script.  Always change the Perl script.
#
EOF

$SECTION=".text";

@K=(0x5a827999,0x6ed9eba1,0x8f1bbcdc,0xca62c1d6);

print <<EOF;
	.text
	.align	2
EOF
for $i (0..1) {
    print ".Lk$i:\t.word   $K[$i]\n";
}
print <<EOF;
	.global  SHA1_Block
	.type	 SHA1_Block, %function
SHA1_Block:
	stmfd	sp!, {r4-r8, r10, fp, ip, lr}
	stmfd	sp!, {r0,r2}

	ldr	r2, [r0, #0]
	ldr	r3, [r0, #4]
	ldr	r4, [r0, #8]
	ldr	r5, [r0, #12]
	ldr	r6, [r0, #16]
	sub	sp, sp, #48
EOF

# register pointing to input buffer
$BUFFER='r1';

# register for A-E and T (cycle)
$A='r2';
$B='r3';
$C='r4';
$D='r5';
$E='r6';
$T='r0';

# register containing K
$K='r7';

# register caching W[i-3] to W[i] and W[i-16] to W[i-15]
@CACHE1 = ('fp','ip', 'lr');
@CACHE2 = ('r8', 'r10');


# Normally SHA1 first transforms the 16 word (64 byte) buffer
# into an 80 word buffer with
#    W[i] = buffer[i]                                       i <  16
#         = ROTATE(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16],1)   i >= 16
#
# We calculate W[i] on the fly, and store the last 14 words on the
# stack (in a cyclic buffer) from  [sp, #0] to [sp, #52] (inclusive)
# The values W[i-15] and W[i-16] are kept in CACHE2[1] and CACHE2[0].
# The values W[i-1] to W[i-3] are kept in CACHE1[2] to CACHE1[0].


# Return the address of W[i-8].
sub W($) {
    my ($i) = @_;
    my $j;
    if ($i < 16) {
	$j = $i*4;
	return "[$BUFFER, #$j]";
    } else {
	$j = 4*(($i-16) % 12);
	return "[sp, #$j]";
    }
}

sub W8($) {
    return W($_[0]-8);
}
sub W14($) {
    return W($_[0]-14);
}
sub W0($) {
    return W($_[0]);
}

# Calculate Fi(B,C,D)  (result in T)
sub FUNC($$$$$) {
    my ($i,$B,$C,$D, $T) = @_;
    if ($i < 20) {
	# F1 = (B & C) | (~B & D) = ((D ^ C) & B) ^ D
	print "\teor    $T, $C, $D\n";
	print "\tand    $T, $B, $T\n";
	print "\teor    $T, $D, $T\n";
    } elsif ($i < 40) {
	# F2 = (B ^ C ^ D)
	print "\teor    $T, $C, $D\n";
	print "\teor    $T, $B, $T\n";
    } elsif ($i < 60) {
	# F3 = ((B & C) | (B & D) | (C & D)) = ((B^C) & (B^D)) ^ B
	print "\teor    $D, $B, $D\n";
	print "\teor    $T, $B, $C\n";
	print "\tand    $T, $D, $T\n";
	print "\teor    $D, $B, $D\n";
	print "\teor    $T, $B, $T\n";
    } else {
	# F4 = (B ^ C ^ D)
	print "\teor    $T, $C, $D\n";
	print "\teor    $T, $B, $T\n";
    }
}

for ($i = 0; $i < 80; $i++) {
    my $tmp;
    print "\n\t\@ Round $i\n";
    print "\t\@ A=$A B=$B C=$C D=$D E=$E\n";
    
    print "\tldr    $K, .Lk".($i/20)."\n" if (($i % 20) == 0) ;
    
    if ($i >= 16) {
	# Calculate W[i].  W[i] = ROTATE(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16],1)
	# CACHE2[0..1]  caches W[i-16..i-15]
	print "\t\@ W[".($i-16)."]=$CACHE2[0] W[".($i-15)."]=$CACHE2[1]";
	# CACHE1[0..2]  caches W[i-3..i-1]
	print " W[".($i-3)."]=$CACHE1[0] W[".($i-2)."]=$CACHE1[1]".
	    " W[".($i-1)."]=$CACHE1[2]\n";

	my $W2 = $CACHE2[0];
	my $W1 = $CACHE1[0];

        # save value of W[i-3] in cyclic buffer (only if it is needed).
	print "\tstr    $W1, ". W($i-3)."\n" if ($i-3 >= 16 && $i-3 < 80-8);

	print "\teor    $W1, $W1, $W2\n";  # W = W[i-3] ^ W[i-16]
	print "\tldr    $W2, ".W8($i)."\n";         
	print "\teor    $W1, $W1, $W2\n";          #  ^ W[i-8]
	print "\tldr    $W2, ".W14($i)."\n";     #      (update cache2)        
	print "\teor    $W1, $W1, $W2\n";          #  ^ W[i-14]
	print "\tmov    $W1, $W1, ror \#31\n";
	# Note that CACHE2[0] now contains W[i-14]
	#       and CACHE1[0] now contains W[i]
	
	print "\tadd    $E, $E, $W1\n";
	
	# cycle cache registers
	$tmp = $CACHE1[0];
	$CACHE1[0] = $CACHE1[1];
	$CACHE1[1] = $CACHE1[2];
	$CACHE1[2] = $tmp;
	
	$tmp = $CACHE2[0];
	$CACHE2[0] = $CACHE2[1];
	$CACHE2[1] = $tmp;
    } else {
	# take W[i] from (%a0) ;  but cache it if we need it later.
	$reg = $i < 2 ? $CACHE2[$i] : $i >= 13 ? $CACHE1[$i-13] : $T;
	print "\tldr    $reg, ". W0($i)."\n";
	print "\tadd    $E, $E, $reg\n";
    }

    print "\tadd    $E, $E, $A, ror \#27\n";
    FUNC($i, $B, $C, $D, $T);
    print "\tadd    $E, $E, $T\n";
    print "\tadd    $E, $E, $K\n";
    
    print "\tmov    $B, $B, ror \#2\n";

    $tmp = $E;
    $E = $D;
    $D = $C;
    $C = $B;
    $B = $A;
    $A = $tmp;
}	

print "\n\t\@ Finishing.\n";

$IN  = $BUFFER;
$OUT = $CACHE2[0];

print <<EOF;
	add    sp, sp, \#48
	ldmfd	sp!, { $IN, $OUT }
	ldr    $T, [$IN, \#0]
	add    $A, $A, $T
	str    $A, [$OUT, \#0]
	ldr    $T, [$IN, \#4]
	add    $B, $B, $T
	str    $B, [$OUT, \#4]
	ldr    $T, [$IN, \#8]
	add    $C, $C, $T
	str    $C, [$OUT, \#8]
	ldr    $T, [$IN, \#12]
	add    $D, $D, $T
	str    $D, [$OUT, \#12]
	ldr    $T, [$IN, \#16]
	add    $E, $E, $T
	str    $E, [$OUT, \#16]
	ldmfd	sp!, {r4-r8, r10, fp, ip, pc}
	.align  2
EOF

for $i (2..3) {
    print ".Lk$i:\t.word   $K[$i]\n";
}

print <<EOF;
	.size  SHA1_Block, .-SHA1_Block
EOF

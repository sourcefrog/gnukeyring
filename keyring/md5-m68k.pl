#!/usr/bin/perl
print <<EOF;
#
# Keyring -- store passwords securely on a handheld
# Copyright (C) 2003 Jochen Hoenicke <hoenicke@users.sourceforge.net>
#
# $Id$
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

#
# This is a hand optimized implementation of MD5.  This assembler code is
# autogenerated by a perl script.  Always change the Perl script.
#
EOF


@K=(
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,

  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,

  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,

  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
    );

@s = ( 
  7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
       );

$A='%d0';
$B='%d1';
$C='%d2';
$D='%d3';
$T='%d4';

$W = 4;

#
# Find out in which section to put this function
#
$SECTION=".text";
open SECTIONS_H, "<sections.h";
while (<SECTIONS_H>) {
    if (/\#define\s+MD5_SECTION\s+__attribute__\s*
	\(\(section\s*\("(.*)"\)\)\)/x) {
	$SECTION = qq(.section\t$1,"x");
	last;
    }
}
close SECTIONS_H;

print <<EOF;

	.file	"md5-m68k.s"

$SECTION
	.even
.globl MD5_Block
MD5_Block:

	link.w %a6,#0
	move.l %d3,-(%sp)
	move.l %d4,-(%sp)
	move.l 8(%a6),%a0
	move.l 12(%a6),%a1
        movm.l (%a0), \#0x000f
EOF

    my $cycles = 16 + 16+168 + 8*8 + 6*16;
    $cycles += (4 + 18 + 4+4+3+12) * (4+$W);



    sub W($) {
	my ($i) = @_;
	my $j;

	if ($i < 15) {
	    return "(%a1)+";
	} elsif ($i < 16) {
	    return "(%a1)";
	} elsif ($i < 32) {
	    $j = 1 + ($i-16)*5;
	} elsif ($i < 48) {
	    $j = 5 + ($i-16)*3;
	} else {
	    $j = 0 + ($i-16)*7;
	}

	$j = (($j & 15) - 15) * 4;
	$j = "" if ($j == 0);
	return "$j(%a1)";
    }
	  
    sub rol($$) {
	my ($i, $A) = @_;
        my $dir = 1;
	if ($i > 16) {
	    $dir = -1;
	    $i = 32 - $i;
	}
	if ($i > 8) {
	    print "\tswap   $A\n";
	    $dir = -$dir;
	    $i = 16 - $i;
	    $cycles += 4+$W;
	}
	if ($i > 0) {
	    print "\tro".($dir > 0 ? "l" : "r").".l  \#$i, $A\n";
	    $cycles += 8+$W+2*$s[$i]
	}
    }

    for ($i = 0; $i < 64; $i++) {
	print "\n\t\# Round $i cycles: $cycles\n";

	print "\tadd.l  ".W($i).", $A\n";
	$cycles += 18 + 4*$W;

	if ($i < 16) {
	    print "\tmove.l $D, $T\n";
	    print "\teor.l  $C, $T\n";
	    print "\tand.l  $B, $T\n";
	    print "\teor.l  $D, $T\n";
	    $cycles += 4 + 8 + 8 + 8 + 4*$W;
	} elsif ($i < 32) {
	    print "\tmove.l $C, $T\n";
	    print "\teor.l  $B, $T\n";
	    print "\tand.l  $D, $T\n";
	    print "\teor.l  $C, $T\n";
	    $cycles += 4 + 8 + 8 + 8 + 4*$W;
	} elsif ($i < 48) {
	    print "\tmove.l $D, $T\n";
	    print "\teor.l  $C, $T\n";
	    print "\teor.l  $B, $T\n";
	    $cycles += 4 + 8 + 8 + 3*$W;
	} else {
	    print "\tmove.l $D, $T\n";
	    print "\tnot.l  $T\n";
	    print "\tor.l   $B, $T\n";
	    print "\teor.l  $C, $T\n";
	    $cycles += 4 + 6 + 8 + 8 + 4*$W;
	}
	print "\tadd.l  $T, $A\n";
	print "\taddi.l \#$K[$i], $A\n";
	&rol($s[$i], $A);
	print "\tadd.l  $B, $A\n";

	$cycles += 8+$W + 16+3*$W + 8+$W;

	$tmp = $D;
	$D = $C;
	$C = $B;
	$B = $A;
	$A = $tmp;
    }	

    print "\n\t\# Finishing.  Cycles: $cycles\n";

print <<EOF;
	move.l 16(%a6),%a1
	add.l (%a0)+,$A
	move.l $A,(%a1)+
	add.l (%a0)+,$B
	move.l $B,(%a1)+
	add.l (%a0)+,$C
	move.l $C,(%a1)+
	add.l (%a0)+,$D
	move.l $D,(%a1)+
	move.l (%sp)+,%d4
	move.l (%sp)+,%d3
	unlk %a6
	rts
	.byte 0x89
	.ascii "MD5_Block"
	.even
	.word 0
EOF
    $cycles += 16 + 4*(16+12) + 12 + 8*8 + 12 + 16;
    $cycles += (4 + 4*6 + 18 + 1 + 1) * $W;
    print "\n\t\# Total cycles: $cycles\n";
